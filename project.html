<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vee</title>
    <link rel="stylesheet" href="style/project.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" integrity="sha512-1ycn6IcaQQ40/MKBW2W4Rhis/DbILU74C1vSrLJxCq57o941Ym01SwNsOMqvEBFlcgUa6xLiPY/NS5R+E6ztJQ==" crossorigin="anonymous" referrerpolicy="no-referrer" />
<link href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,400;0,500;1,500&display=swap" rel="stylesheet">
</head>


<html>
<h2>WEEK 1</h2>
<p>Research on the GPIOS found out tha there was 40 pins.</p>
<p>Installation of Thonny IDE and micropython.</p>
<img src="https://pico.raspi.vom-kuhberg.de/_img/raspi_pico_pinout.gif" alt="raspi_pico_pinout" width="104" height="142">
<p>Learn basis on using Thonny,commands and the shell.Noted that the RPI has the communication protocals for everycode to be save as (name.py).By write a code to blink the on board LED(gpio 25) the following commands were introduced.</p>
<code>from machine import Pin<br>
    from time import sleep<br>
    
    led = Pin(25,Pin.OUT)<br>

    while True:<br>
        &nbsp;led.on()<br>
        &nbsp;sleep(1)<br>
        &nbsp;led.off()<br>
        &nbsp;sleep(1)<br>
    
    </code>
    
<p>Further, I was able to introduce an external LED</p>
    <code>from machine import Pin<br>
        from time import sleep<br>
    
        led = Pin(16, Pin.OUT)<br>

        while True:<br>
        led.on()<br>
        sleep(1)<br>
        led.off()<br>
        sleep(1)<br>

    </code>
<img src="media/Ex.LED.jpg" alt="led image" width="104" height="142">
<h3>WEEK 2</h3>
<h4>Module 2</h4>
<p>For this module,learned about electric circuit principles where button switch,buzzers,PWM,Potentiometer and LED's whereby interfacing each component.Used each spreadsheet to have a better understanding on the components.Resistors used pull up for the current value to be 1V for the loop and pull down to be 0v.Potential divider to know the voltage in each loop,the impendance and current limiting.</p>
<p>Interfacing a LED with a button switch</p>
<code>from machine import Pin<br>
    import time<br>
    
    led = Pin(15, Pin.OUT)<br>
    button = Pin(14, Pin.IN, Pin.PULL_DOWN)<br>
    
    while True:<br>
        if button.value():<br>
            led.toggle()<br>
            time.sleep(0.5)<br>
        </code>
<img src="media/buttonled.jpg" alt="button.led" width="104" height="142">
<p>Interfacing a LED with a potentiometer to vary the brightness which is an analogue input.</p> 
<video width="320" height="240" controls>
    <source src="media/video1.mp4" type="video/mp4">
    Your browser does not support the video tag.
  </video> 
<p>Projects done after incorporating the components was traffic and binary lights.Traffic lights uisng a Red,Amber and Green LED's while for binary counter(3^2) threebit_counter.</p>  
<p>Traffic light</p> 
<code>
    from machine import Pin<br>
from time import sleep<br>
 
# traffict lights(red, amber, green)<br>
red = Pin(13,Pin.OUT)<br>
amber = Pin(14,Pin.OUT)<br>
green = Pin(15,Pin.OUT)<br>

while True:<br>
    &nbsp;gred.on()<br>
    &nbsp;amber.off()<br>
    &nbsp;green.off()<br>
    &nbsp;sleep(.5)<br>
    
    &nbsp;red.off()<br>
    &nbsp;amber.on()<br>
    &nbsp;green.off()<br>
    &nbsp;sleep(.5)<br>
    
    &nbsp;red.off()<br>
    &nbsp;amber.off()<br>
    &nbsp;green.on()<br>
    &nbsp;sleep(.5)<br>

    <video width="320" height="240" controls>
        <source src="media/trafficlights.mp4" type="video/mp4" alt="ledtraffic.lights">
        Your browser does not support the video tag.
      </video>

<p>three binary counter</p>
<code>
from machine import Pin<br>
from time import sleep<br>

red = Pin(15, Pin.OUT)<br>
amber = Pin(13, Pin.OUT)<br>
green = Pin(11, Pin.OUT)<br>

while True:<br>

    red.off()<br>
    amber.off()<br>
    green.off()<br>
    sleep(.1)<br>
    
    amber.off()<br>
    red.off()<br>
    green.on()<br>
    sleep(1)<br>
    
    red.off()<br>
    amber.off()<br>
    green.on()<br>
    sleep(.1)<br>
    
    red.off()<br>
    amber.on()<br>
    green.on()<br>
    sleep(.1)<br>
    
    red.on()<br>
    amber.off()<br>
    green.off()<br>
    sleep(.1)<br>


    red.on()<br>
    amber.on()<br>
    green.off()<br>
    sleep(.1)<br>
    

    red.on()<br>
    amber.off()<br>
    green.on()<br>
     sleep(.1)<br>
    

    red.on()<br>
    amber.on()<br>
    green.on()<br>

</code>
<video width="320" height="240" controls>
    <source src="media/binarycounter.mp4" "type="threebitcounter" alt="threecounter">
     Your browser does not support the video tag.
  </video>
<p>Also,Sensors and actuators where introduced whereby the sensor is a device that produces an output signal for the purpose of sensing a physical phenomenon and an actuator a component of a machine that produces force, torque, or displacement, usually in a controlled way, when an electrical, pneumatic or hydraulic input is supplied to it in a system (called an actuating system).The sensors introduced where ULTRASONIC sensor (HCSR401) and PIR.The HC-SR401 working principle is to emmit a high frequecy signal that is beyond the human hearing(echo) where the transmitter does and the receiver bounces back using a 30 degree angle(trigger).</p>
<p>The HC-SR401 has 4 pins containing the Vcc, Echo, Trigger and Ground.Below image:</p>
<img src="media/HC-SR04.webp" alt="Ultrassonic.image" width="150" height="142">
<p>Simulation code </p>
<code> 
    from machine import Pin<br>
from time import sleep<br>

trigger = Pin(3, Pin.OUT)<br>
echo = Pin(2, Pin.IN)<br>

def ultra():<br>
    trigger.low()<br>
    sleep(2)<br>
    trigger.high()<br>
    sleep(2)<br>
    trigger.low()<br>
    while echo.value() == 0:<br>
        signaloff = ticks_us()<br>
    while echo.value() == 1:<br>
        signalon = ticks_us()<br>
        timepassed = signalon - signaloff<br>
        distance = (timepassed * 0.0343) / 2<br>
        print("The distance from the objects is",distance,"cm")<br>

while True:<br>
    ultra()<br>
    sleep(1)<br>
    
</code>
<img src="media/ultrasonic.jpg" alt="RPI.ultrasonic" width="140" length="140"> 
<p>Went further for the assignment when oled was used in combo to display the binary counter.For the OLED to be used a Library was install (SSD1306).</p>
<code>
    from machine import Pin, SPI<br>
from time import sleep<br>
import framebuf<br>
from ssd1306 import SSD1306_SPI<br>

spi = SPI(0, 100000, mosi=Pin(19), sck=Pin(18))<br>
oled = SSD1306_SPI(128, 64, spi, Pin(17), Pin(20), Pin(16))<br>

while True:<br>
    oled.text("Hello Victoria",10,28)<br>
    oled.show()<br>

</code>
<img src="media/OLED.jpg" alt="OLED display" width="150" length="150">
<p>Threebinary_counter interfacing with OLED</p>
<code>
from machine import Pin, SPI<br>
from time import sleepfrom machine import Pin, SPIfrom machine import Pin, SPI<br>
from time import sleep<br>
import framebuf<br>
from ssd1306 import SSD1306_SPI<br>

red = Pin(15, Pin.OUT)<br>
amber = Pin(13, Pin.OUT)<br>
green = Pin(11, Pin.OUT)<br>

spi = SPI(0, 100000, mosi=Pin(19), sck=Pin(18))<br>
oled = SSD1306_SPI(128, 64, spi, Pin(17),Pin(20), Pin(16))<br>

while True:<br>
    oled.text("counter 0",30,28)<br>
    oled.show()<br>
    red.off()<br>
    amber.off()<br>
    green.off()<br>
    sleep(.1)<br>
    
    oled.fill(0)<br>
    oled.show()<br>
    amber.off()<br>
    red.off()<br>
    green.on()<br>
    sleep(.1)<br>
    oled.text("counter 1",30,28)<br>
    oled.show()<br>
    sleep(1)<br>
    
    oled.fill(0)<br>
    oled.show()<br>
    red.off()<br>
    amber.off()<br>
    green.on()<br>
    oled.text("counter 2",30,28)<br>
    oled.show()<br>
    sleep(.1)<br>
    
    oled.fill(0)<br>
    oled.show()<br>
    red.off()<br>
    amber.on()<br>
    green.on()<br>
    oled.text("counter 3",30,28)<br>
    oled.show()<br>
    sleep(.1)<br>
    
    oled.fill(0)<br>
    oled.show()<br>
    red.on()<br>
    amber.off()<br>
    green.off()<br>
    oled.text("counter 4",30,28)<br>
    oled.show()<br>
    sleep(.1)<br>
   
    oled.fill(0)<br>
    oled.show()<br>
    red.on()<br>
    amber.on()<br>
    green.off()<br>
    oled.text("counter 5",30,28)<br>
    oled.show()<br>
    sleep(.1)<br>
    
    oled.fill(0)<br>
    oled.show()<br>
    red.on()<br>
    amber.off()<br>
    green.on()<br>
    oled.text("counter 6",30,28)<br>
    oled.show()<br>
    sleep(1)<br>
    

    oled.fill(0)<br>
    oled.show()<br>
    red.on()<br>
    amber.on()<br>
    green.on()<br>
    oled.text("counter 7",30,28)<br>
    oled.show()<br>
    sleep(1)<br>
    from machine import Pin, SPI<br>
    from time import sleep<br>
    import framebuf<br>
    from ssd1306 import SSD1306_SPI<br>
    
    red = Pin(15, Pin.OUT)<br>
    amber = Pin(13, Pin.OUT)<br>
    green = Pin(11, Pin.OUT)<br>

<video width="320" height="240" controls>
    <source src="media/binarycounter.mp4" "type="binary lights" alt="threebit_counter">
    
    Your browser does not support the video tag.
</video>
<h4>MODULE 3</h4>
<h5>Microcontroller programming and access system control</h5>
<P>For this module ESP wroom32 that has both access to bluetooth and wifi connection.Serial communication protocal which is the UART,SPI and i2c.It has 38 pins 3 grounds and two ADC pins used as a  Transmitter(TX) and Receiver(RX).Serial communication for the ESP32 where transfer of data can be series and parallel where he bits are either single or multiple.Sychronous serail where bits use the clock signal while asychronous no external clock signal. </P>
<p>SPI meaning Serial Periphal Interfaces.It uses separate clock and data lines, along with a select line to choose the device you wish to talk to.</p>
<h6>Baud rate </h6>
<p>The baud rate specifies how fast data is sent over a serial line. It's usually expressed in units of bits-per-second (bps).Then speed rane is always between 1200-115200.I2C meaning Inter-intergrated circuit where communication of two digital circuits chips allowed to communicate this includes SCL(Serial clock signal) and SDL(serial data).</p>
<img src="media/ESPwroom32.png" alt="ESPwroom32" width="140" length="142".>
<p>ESP32 also works the same as raspberry pi pico,onboard LED is given a particular code and blinks.The ESP32 uses the Arduino IDE software to code.The following is the code that i wrote for the onboard LED. </p>
<code>int ledPin = 2;<br>

    void setup() {<br>
      pinMode(ledPin, OUTPUT);<br>
    }<br>
    
    void loop() {<br>
      digitalWrite(ledPin, HIGH);<br>
      delay(500);<br>
      digitalWrite(ledPin, LOW);<br>
      delay(500);<br>
    }<br>
    </code>
<p>Traffic lights and binaty counter with ESP32.</p>
<code>
    int red = 2;<br>
int amber = 4;<br>
int green = 5;<br>

void setup() {><br>

  Serial.begin(115200);<br>
  pinMode(red,OUTPUT);<br>
  pinMode(amber,OUTPUT);<br>
  pinMode(green,OUTPUT);<br>
}<br>

void loop() {<br>
 digitalWrite(red, HIGH);<br>
 Serial.println("RED HIGH"); <br>
  delay(100);<br>
  digitalWrite(red,LOW);<br>
  Serial.println("RED LOW");<br> 
delay(100);<br>

digitalWrite(amber, HIGH);<br>
 Serial.println("AMBER HIGH"); <br>
  delay(100);<br>
  digitalWrite(amber,LOW);<br>
  Serial.println("AMBER LOW");<br>
delay(100);<br>

digitalWrite(green, HIGH);<br>
 Serial.println("GREEN HIGH");<br> 
  delay(100);<br>
  digitalWrite(green,LOW);<br>
  Serial.println("GREEN LOW"); <br>
delay(100);<br>

}<br>
</code>
<p>Researched further, found out ESP32 can be used with other IoT devices such as LoRa.ESP32 needs a libraries files that are found in Tool-manage libraries then install.</p>
<p>Interfacing the ESP32 with the oled display.Adafruit _GFX for graphics and Adafruit_SSD1306.</p>
<code>
    #include <SPI.h><br>
        #include <Wire.h><br>
        #include <Adafruit_GFX.h><br>
        #include <Adafruit_SSD1306.h><br>
        
        #define SCREEN_WIDTH 128<br>
        #define SCREEN_HEIGHT 64<br>
        
        #define OLED_MOSI   23<br>
        #define OLED_CLK    18<br>
        #define OLED_DC     16<br>
        #define OLED_CS     5<br>
        #define OLED_RESET  17<br>
        
        Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT,<br>
          OLED_MOSI, OLED_CLK, OLED_DC, OLED_RESET, OLED_CS);<br>
        
        void setup() {<br>
          Serial.begin(115200);<br>
        
          if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { // Address 0x3D for 128x64<br>
            Serial.println(F("SSD1306 allocation failed"));<br>
            for(;;);<br>
          }<br>
          delay(2000);<br>
          display.clearDisplay();<br>
        
          display.setTextSize(1);<br>
          display.setTextColor(WHITE);<br>
          display.setCursor(0, 10);<br>
          // Display static text<br>
          display.println("Hello, world!");<br>
          display.display();<br> 
        }<br>
        
        void loop() {<br>
          
        }<br>
</code>
<img src="media/oledwith esp32.jpg" alt="esp32oled" width="150" length="142"><br>

<h>MODULE 4</h>
    <p>SERIAL PROTOCAL</p> 

<p>For this module serial communication protocal 12C AND SPI in Arduino.When using SPI a library is installed for proper communication.When sending data the CIPO is responsible for the transmission while COPI is for receiving data. </p>
<p>Then,The clock pulses which synchronize data transmission generated by the Controller and one line specific for every device with Serial clock(scl) and the pin on each device that the Controller can use to enable and disable specific devices. When a device's Chip Select pin is low, it communicates with the Controller. When it's high, it ignores the Controller. This allows you to have multiple SPI devices sharing the same CIPO, COPI, and SCK lines.</p> 
<p>The SPI has a speed of 15mhz when its able to adjust.The SPI standard is loose and each device implements it a little differently. This means you have to pay special attention to the device's datasheet when writing your code.</p>
<h>Serial Peripheral Interface (SPI)</h>
<p>Serial Peripheral Interface (SPI) is an interface bus commonly used to send data between microcontrollers and small peripherals such as shift registers, sensors, and SD cards. It uses separate clock and data lines, along with a select line to choose the device you wish to talk to.</p>
<p>A common serial port, the kind with TX and RX lines, is called "asynchronous" (not synchronous) because there is no control over when data is sent or any guarantee that both sides are running at precisely the same rate.</p>
<p>SPI works differently with asychronous serial communication wherew the baud rate must aggre wth the interfacing devices and adding an extra bit start and stop bit is added.While Sychronous it uses separate lines for data and a clock that keeps both sides in perfect sync.SPI communicates well with sensors whereby the transmitting and receiving data can be done at ths same time with interruption. </p>
<p>The Chip select is also an important section during sending data in multiple devices.This tells the devices to wake up when low to transmit data and when high it disconnects from the peripherals. </p>

<h>AHT1O(Temparature and Humidity )</h>
<p>This device uses i2c communication.Library neede for the AHT1O is install.To ensure the aadress is correct a program is written.</p>
</code>from ahtx0 import AHT10<br>
from machine import Pin, I2C<br>
i2c = I2C(1, scl=Pin(15), sda=Pin(14))<br>
sensor = ahtx0.AHT10(i2c)<br>

temperature = round(sensor.temperature, 2)<br>
humidity = round(sensor.relative_humidity, 2)<br>
while True:<br>
    print("Temperature: ", temperature, "c")<br>
    print("Humidity: ", humidity, "%")<br>
    print()<br>
</code>
<img src="AHT10.jpg" alt="AHT10_pinout" width="104" height="142">
<a href="AHT10.jpg"> AHT10 image</a>
<p>AHT10 will read the r.t.p of the room had to add OLED to display the temperature and humidity.With teh followig code.</p>
<img src="OLED-AHT10.jpg" alt="oled-aht10" width="140" length="142">
<code>from ahtx0 import AHT10<br>


    from machine import Pin, I2C, SPI<br>
    from time import sleep<br>
    import framebuf<br>
    from ssd1306 import SSD1306_SPI<br>
    
    # Set up the I2C protocol on I2C controller 1 (there's also 0)<br>
    
    # I2C controller 1 is connected to GPIO 15 (SCL) and 14 (SDA)<br>
    
    # Refer to your Pico pinout for the I2C pins and controller numbers<br>
    
    spi = SPI(0, 100000, mosi=Pin(19), sck=Pin(18))<br>
    oled = SSD1306_SPI(128, 64, spi, Pin(17), Pin(20), Pin(16))<br>
    i2c = I2C(1, scl=Pin(15), sda=Pin(14))<br>
    
    
    # Create our sensor object from the ahtx0 library using i2c<br>
    
    sensor = AHT10(i2c)<br>
    temperature = round(sensor.temperature, 2)<br>
    humidity = round(sensor.relative_humidity, 2)<br>
    
    while True:<br>
        print("Temperature: ", temperature, "c")<br>
        print("Humidity: ", humidity, "%")<br>
        print()<br>
        oled.text("Temperature",0,0)<br>
        oled.text(str(temperature),0,15)<br>
        oled.text("C",45,15)<br>
        oled.text("Humidity",0,28)<br>
        oled.text(str(humidity),0,38)<br>
        oled.text("%",45,38)<br>
        oled.show()<br>
        sleep(2)<br>
        </code><br>

<h10>Interfacing ESPwroom32,OLED and AHT10</h10>
<p>By usig Arduino IDE to write a code for esp32.</p>
<code>#include <Wire.h><br>
    #include <SPI.h><br>
    #include <Wire.h><br>
    #include <Adafruit_GFX.h><br>
    #include <Adafruit_SSD1306.h><br>
    
    // Define AHT10 register addresses<br>
    #define AHT10_ADDR 0x38<br>
    #define CMD_MEASURE 0xAC<br>
    #define CMD_SOFTRESET 0xBA<br>
    #define STATUS_BUSY_MASK 0x80<br>
    #define SCREEN_WIDTH 128<br>
    #define SCREEN_HEIGHT 64<br>
    
    // Define I2C0 pins<br>
    #define SDA_PIN 21<br>
    #define SCL_PIN 22<br>
    #define OLED_MOSI   23 //(SDA)<br>
    #define OLED_CLK    18 //SCL<br>
    #define OLED_DC     16<br>
    #define OLED_CS     5<br>
    #define OLED_RESET  17<br>
    
    Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT,<br>
      OLED_MOSI, OLED_CLK, OLED_DC, OLED_RESET, OLED_CS);<br>
    
    // Global variables for sensor data<br>
    float temperature = 0.0;<br>
    float humidity = 0.0;<br>
    
    // Function to read AHT10 sensor<br>
    void readAHT10() {<br>
      // Send measurement command to AHT10<br>
      Wire.beginTransmission(AHT10_ADDR);<br>
      Wire.write(CMD_MEASURE);<br>
      Wire.write(0x33);<br>
      Wire.write(0x00);<br>
      Wire.endTransmission();<br>
      
      // Wait for measurement to complete<br>
      while (true) {<br>
        Wire.beginTransmission(AHT10_ADDR);<br>
        Wire.write(0x71);<br>
        Wire.endTransmission(false);<br>
        Wire.requestFrom(AHT10_ADDR, 1);<br>
        if ((Wire.read() & STATUS_BUSY_MASK) == 0) break;<br>
        delay(10);<br>
      }<br>
    
      // Read measurement data from AHT10<br>
      Wire.beginTransmission(AHT10_ADDR);<br>
      Wire.write(0x00);<br>
      Wire.endTransmission(false);<br>
      Wire.requestFrom(AHT10_ADDR, 6);<br>
      uint8_t msb = Wire.read();<br>
      uint8_t lsb = Wire.read();<br>
      uint8_t cksum = Wire.read();<br>
      uint32_t raw_data = ((msb << 16) | (lsb << 8) | cksum) >> 4;<br>
    
      // Convert raw data to temperature and humidity<br>
      temperature = (float)(raw_data * 200.0 / 1048576.0) - 50.0;<br>
      humidity = (float)(raw_data * 100.0 / 1048576.0);<br>
    }<br>
    
    void setup() {<br>
      // Initialize serial communication<br>
      Serial.begin(9600);<br>
    
      // Initialize I2C communication on I2C0 with custom SDA and SCL pins<br>
      Wire.begin(SDA_PIN, SCL_PIN);<br>
      
      // Soft reset AHT10<br>
      Wire.beginTransmission(AHT10_ADDR);<br>
      Wire.write(CMD_SOFTRESET);<br>
      Wire.endTransmission();<br>
    
      if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { // Address 0x3D for 128x64<br>
        Serial.println(F("SSD1306 allocation failed"));<br>
        for(;;);<br>
      }<br>
      delay(2000);<br>
    }<br>
    
    void loop() {<br>
      // Read data from AHT10<br>
      readAHT10();<br>
    
      // Print temperature and humidity values to serial monitor<br>
      Serial.print("Temperature: ");<br>
      Serial.print(temperature, 2); // round to 2 decimal places<br>
      Serial.print(" C, Humidity: ");<br>
      Serial.print(humidity, 2); // round to 2 decimal places<br>
      Serial.println(" %");<br>
    
      // Wait 1 second before taking another measurement<br>
      delay(1000);<br>
    
      display.clearDisplay();<br>
    
      display.setTextSize(1);<br>
      display.setTextColor(WHITE);<br>
      display.setCursor(0, 10);<br>
      // Display static text<br>
      display.println("Temperature");<br>
      display.setCursor(0, 20);<br>
      // Display static text<br>
      display.println(temperature, 2);<br>
    
    
      display.setCursor(0, 30);<br>
      // Display static text<br>
      display.println("Humidity");<br>
      display.setCursor(0, 40);<br>
      // Display static text<br>
      display.println(humidity, 2);<br>
      display.display(); <br>
      
    }</code><br>
<img src="oled-aht10-esp32.jpg" alt="oled,esp32 and aht10" width="142" length="140"><br>

<h11>Interfacing Raspberry with RFID to get the UID of the card and key tag. </h11>
<p>For every RFID they have an identifier and address.For example,</p>
<video width="320" height="240" controls>
    <source src="RFID card.mp4" type="video/mp4">
    Your browser does not support the video tag.
    </video>
<video width="320" height="240" controls>
    <source src="RFID keytag.mp4" type="video/mp4">
    Your browser does not support the video tag.
     </video>   
    
<h12>ESPwroom32 serial communication with Raspberry pico</h12>

<p>For this practice the data acquisation is through the TX which is the transmitter while RX is the receiver.Communication through the serial bar when the ESP32 led will blink then Raspberry pico onboard led and vice versa.</p>
<p>The code written in raspberry</p>
<code> Code for Raspberry Pi Pico<br>
    #Source: Electrocredible.com, Language: MicroPython.<br>
from machine import Pin,UART<br>
import time<br>
uart = UART(1, baudrate=9600, tx=Pin(4), rx=Pin(5))<br>
uart.init(bits=8, parity=None, stop=2)<br>
led = Pin("LED", Pin.OUT)<br>

while True:<br>
    uart.write('t')<br>
    if uart.any():<br> 
        data = uart.read() <br>
        if data== b'm':<br>
            led.toggle()<br> 
    time.sleep(1)<br>
    </code>
<p>ESP32 uses the SPI communication protocal,using the Arduino IDE some libraries are installed.</p>
<code> bool ledState=1; //variable used to save the state of LED<br>
    void setup() {<br>
      Serial.begin(9600);// set baud rate to 9600<br>
      pinMode(LED_BUILTIN, OUTPUT);<br>
    }<br>
    
    void loop() {<br> 
      if(Serial.read()== 't') {<br>
      digitalWrite(LED_BUILTIN, ledState);<br>
      ledState=!ledState;<br>
      Serial.print('m'); //write 'm' to the UART<br>
      }<br> 
    }<br>
</code><br>
<video width="320" height="240" controls>
    <source src="ESP32-rpi pico.mp4" type="video/mp4">
    Your browser does not support the video tag.
  </video><br>

<h13>MODULE 5</h13><br>
<h14>Microcontroller programming and control access III</h14>
<p>For this project,we interfaced raspberry pico,RFID,LED and OLED for a simple access and display.But also a RGB can be used instead of two LED's</p>
<p>The OLED was to show the access granted or denied while the green for granted and red for denied.</p>
<video width="320" height="240" controls>
    <source src="rfid-oled-led.mp4" type="video/mp4">
    Your browser does not support the video tag.
    </video>
 
    
  
 
</html>

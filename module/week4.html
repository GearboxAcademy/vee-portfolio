<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vee</title>
    <link rel="stylesheet" href="style/project.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" integrity="sha512-1ycn6IcaQQ40/MKBW2W4Rhis/DbILU74C1vSrLJxCq57o941Ym01SwNsOMqvEBFlcgUa6xLiPY/NS5R+E6ztJQ==" crossorigin="anonymous" referrerpolicy="no-referrer" />
<link href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,400;0,500;1,500&display=swap" rel="stylesheet">
</head>
<h>MODULE 4</h>
    <p>SERIAL PROTOCAL</p> 

<p>For this module serial communication protocal 12C AND SPI in Arduino.When using SPI a library is installed for proper communication.When sending data the CIPO is responsible for the transmission while COPI is for receiving data. </p>
<p>Then,The clock pulses which synchronize data transmission generated by the Controller and one line specific for every device with Serial clock(scl) and the pin on each device that the Controller can use to enable and disable specific devices. When a device's Chip Select pin is low, it communicates with the Controller. When it's high, it ignores the Controller. This allows you to have multiple SPI devices sharing the same CIPO, COPI, and SCK lines.</p> 
<p>The SPI has a speed of 15mhz when its able to adjust.The SPI standard is loose and each device implements it a little differently. This means you have to pay special attention to the device's datasheet when writing your code.</p>
<h>Serial Peripheral Interface (SPI)</h>
<p>Serial Peripheral Interface (SPI) is an interface bus commonly used to send data between microcontrollers and small peripherals such as shift registers, sensors, and SD cards. It uses separate clock and data lines, along with a select line to choose the device you wish to talk to.</p>
<p>A common serial port, the kind with TX and RX lines, is called "asynchronous" (not synchronous) because there is no control over when data is sent or any guarantee that both sides are running at precisely the same rate.</p>
<p>SPI works differently with asychronous serial communication wherew the baud rate must aggre wth the interfacing devices and adding an extra bit start and stop bit is added.While Sychronous it uses separate lines for data and a clock that keeps both sides in perfect sync.SPI communicates well with sensors whereby the transmitting and receiving data can be done at ths same time with interruption. </p>
<p>The Chip select is also an important section during sending data in multiple devices.This tells the devices to wake up when low to transmit data and when high it disconnects from the peripherals. </p>

<h>AHT1O(Temparature and Humidity )</h>
<p>This device uses i2c communication.Library neede for the AHT1O is install.To ensure the aadress is correct a program is written.</p>
</code>from ahtx0 import AHT10<br>
from machine import Pin, I2C<br>
i2c = I2C(1, scl=Pin(15), sda=Pin(14))<br>
sensor = ahtx0.AHT10(i2c)<br>

temperature = round(sensor.temperature, 2)<br>
humidity = round(sensor.relative_humidity, 2)<br>
while True:<br>
    print("Temperature: ", temperature, "c")<br>
    print("Humidity: ", humidity, "%")<br>
    print()<br>
</code>
<img src="AHT10.jpg" alt="AHT10_pinout" width="104" height="142">
<a href="AHT10.jpg"> AHT10 image</a>
<p>AHT10 will read the r.t.p of the room had to add OLED to display the temperature and humidity.With teh followig code.</p>
<img src="OLED-AHT10.jpg" alt="oled-aht10" width="140" length="142">
<code>from ahtx0 import AHT10<br>


    from machine import Pin, I2C, SPI<br>
    from time import sleep<br>
    import framebuf<br>
    from ssd1306 import SSD1306_SPI<br>
    
    # Set up the I2C protocol on I2C controller 1 (there's also 0)<br>
    
    # I2C controller 1 is connected to GPIO 15 (SCL) and 14 (SDA)<br>
    
    # Refer to your Pico pinout for the I2C pins and controller numbers<br>
    
    spi = SPI(0, 100000, mosi=Pin(19), sck=Pin(18))<br>
    oled = SSD1306_SPI(128, 64, spi, Pin(17), Pin(20), Pin(16))<br>
    i2c = I2C(1, scl=Pin(15), sda=Pin(14))<br>
    
    
    # Create our sensor object from the ahtx0 library using i2c<br>
    
    sensor = AHT10(i2c)<br>
    temperature = round(sensor.temperature, 2)<br>
    humidity = round(sensor.relative_humidity, 2)<br>
    
    while True:<br>
        print("Temperature: ", temperature, "c")<br>
        print("Humidity: ", humidity, "%")<br>
        print()<br>
        oled.text("Temperature",0,0)<br>
        oled.text(str(temperature),0,15)<br>
        oled.text("C",45,15)<br>
        oled.text("Humidity",0,28)<br>
        oled.text(str(humidity),0,38)<br>
        oled.text("%",45,38)<br>
        oled.show()<br>
        sleep(2)<br>
        </code><br>

<h10>Interfacing ESPwroom32,OLED and AHT10</h10>
<p>By usig Arduino IDE to write a code for esp32.</p>
<code>#include <Wire.h><br>
    #include <SPI.h><br>
    #include <Wire.h><br>
    #include <Adafruit_GFX.h><br>
    #include <Adafruit_SSD1306.h><br>
    
    // Define AHT10 register addresses<br>
    #define AHT10_ADDR 0x38<br>
    #define CMD_MEASURE 0xAC<br>
    #define CMD_SOFTRESET 0xBA<br>
    #define STATUS_BUSY_MASK 0x80<br>
    #define SCREEN_WIDTH 128<br>
    #define SCREEN_HEIGHT 64<br>
    
    // Define I2C0 pins<br>
    #define SDA_PIN 21<br>
    #define SCL_PIN 22<br>
    #define OLED_MOSI   23 //(SDA)<br>
    #define OLED_CLK    18 //SCL<br>
    #define OLED_DC     16<br>
    #define OLED_CS     5<br>
    #define OLED_RESET  17<br>
    
    Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT,<br>
      OLED_MOSI, OLED_CLK, OLED_DC, OLED_RESET, OLED_CS);<br>
    
    // Global variables for sensor data<br>
    float temperature = 0.0;<br>
    float humidity = 0.0;<br>
    
    // Function to read AHT10 sensor<br>
    void readAHT10() {<br>
      // Send measurement command to AHT10<br>
      Wire.beginTransmission(AHT10_ADDR);<br>
      Wire.write(CMD_MEASURE);<br>
      Wire.write(0x33);<br>
      Wire.write(0x00);<br>
      Wire.endTransmission();<br>
      
      // Wait for measurement to complete<br>
      while (true) {<br>
        Wire.beginTransmission(AHT10_ADDR);<br>
        Wire.write(0x71);<br>
        Wire.endTransmission(false);<br>
        Wire.requestFrom(AHT10_ADDR, 1);<br>
        if ((Wire.read() & STATUS_BUSY_MASK) == 0) break;<br>
        delay(10);<br>
      }<br>
    
      // Read measurement data from AHT10<br>
      Wire.beginTransmission(AHT10_ADDR);<br>
      Wire.write(0x00);<br>
      Wire.endTransmission(false);<br>
      Wire.requestFrom(AHT10_ADDR, 6);<br>
      uint8_t msb = Wire.read();<br>
      uint8_t lsb = Wire.read();<br>
      uint8_t cksum = Wire.read();<br>
      uint32_t raw_data = ((msb << 16) | (lsb << 8) | cksum) >> 4;<br>
    
      // Convert raw data to temperature and humidity<br>
      temperature = (float)(raw_data * 200.0 / 1048576.0) - 50.0;<br>
      humidity = (float)(raw_data * 100.0 / 1048576.0);<br>
    }<br>
    
    void setup() {<br>
      // Initialize serial communication<br>
      Serial.begin(9600);<br>
    
      // Initialize I2C communication on I2C0 with custom SDA and SCL pins<br>
      Wire.begin(SDA_PIN, SCL_PIN);<br>
      
      // Soft reset AHT10<br>
      Wire.beginTransmission(AHT10_ADDR);<br>
      Wire.write(CMD_SOFTRESET);<br>
      Wire.endTransmission();<br>
    
      if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { // Address 0x3D for 128x64<br>
        Serial.println(F("SSD1306 allocation failed"));<br>
        for(;;);<br>
      }<br>
      delay(2000);<br>
    }<br>
    
    void loop() {<br>
      // Read data from AHT10<br>
      readAHT10();<br>
    
      // Print temperature and humidity values to serial monitor<br>
      Serial.print("Temperature: ");<br>
      Serial.print(temperature, 2); // round to 2 decimal places<br>
      Serial.print(" C, Humidity: ");<br>
      Serial.print(humidity, 2); // round to 2 decimal places<br>
      Serial.println(" %");<br>
    
      // Wait 1 second before taking another measurement<br>
      delay(1000);<br>
    
      display.clearDisplay();<br>
    
      display.setTextSize(1);<br>
      display.setTextColor(WHITE);<br>
      display.setCursor(0, 10);<br>
      // Display static text<br>
      display.println("Temperature");<br>
      display.setCursor(0, 20);<br>
      // Display static text<br>
      display.println(temperature, 2);<br>
    
    
      display.setCursor(0, 30);<br>
      // Display static text<br>
      display.println("Humidity");<br>
      display.setCursor(0, 40);<br>
      // Display static text<br>
      display.println(humidity, 2);<br>
      display.display(); <br>
      
    }</code><br>
<img src="oled-aht10-esp32.jpg" alt="oled,esp32 and aht10" width="142" length="140"><br>

<h11>Interfacing Raspberry with RFID to get the UID of the card and key tag. </h11>
<p>For every RFID they have an identifier and address.For example,</p>
<video width="320" height="240" controls>
    <source src="RFID card.mp4" type="video/mp4">
    Your browser does not support the video tag.
    </video>
<video width="320" height="240" controls>
    <source src="RFID keytag.mp4" type="video/mp4">
    Your browser does not support the video tag.
     </video>   
    
<h12>ESPwroom32 serial communication with Raspberry pico</h12>

<p>For this practice the data acquisation is through the TX which is the transmitter while RX is the receiver.Communication through the serial bar when the ESP32 led will blink then Raspberry pico onboard led and vice versa.</p>
<p>The code written in raspberry</p>
<code> Code for Raspberry Pi Pico<br>
    #Source: Electrocredible.com, Language: MicroPython.<br>
from machine import Pin,UART<br>
import time<br>
uart = UART(1, baudrate=9600, tx=Pin(4), rx=Pin(5))<br>
uart.init(bits=8, parity=None, stop=2)<br>
led = Pin("LED", Pin.OUT)<br>

while True:<br>
    uart.write('t')<br>
    if uart.any():<br> 
        data = uart.read() <br>
        if data== b'm':<br>
            led.toggle()<br> 
    time.sleep(1)<br>
    </code>
<p>ESP32 uses the SPI communication protocal,using the Arduino IDE some libraries are installed.</p>
<code> bool ledState=1; //variable used to save the state of LED<br>
    void setup() {<br>
      Serial.begin(9600);// set baud rate to 9600<br>
      pinMode(LED_BUILTIN, OUTPUT);<br>
    }<br>
    
    void loop() {<br> 
      if(Serial.read()== 't') {<br>
      digitalWrite(LED_BUILTIN, ledState);<br>
      ledState=!ledState;<br>
      Serial.print('m'); //write 'm' to the UART<br>
      }<br> 
    }<br>
</code><br>
<video width="320" height="240" controls>
    <source src="ESP32-rpi pico.mp4" type="video/mp4">
    Your browser does not support the video tag.
  </video><br>
  </html>